// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: prizes.sql

package db

import (
	"context"
)

const createPrize = `-- name: CreatePrize :one
INSERT INTO prizes (
    prize_name,
    pic_path,
    weight
) VALUES (
  $1, $2, $3
)
RETURNING prize_id, prize_name, pic_path, weight, reviser_id, revise_time, creator_id, create_time
`

type CreatePrizeParams struct {
	PrizeName string `json:"prizeName"`
	PicPath   string `json:"picPath"`
	Weight    int32  `json:"weight"`
}

func (q *Queries) CreatePrize(ctx context.Context, arg CreatePrizeParams) (Prize, error) {
	row := q.queryRow(ctx, q.createPrizeStmt, createPrize, arg.PrizeName, arg.PicPath, arg.Weight)
	var i Prize
	err := row.Scan(
		&i.PrizeID,
		&i.PrizeName,
		&i.PicPath,
		&i.Weight,
		&i.ReviserID,
		&i.ReviseTime,
		&i.CreatorID,
		&i.CreateTime,
	)
	return i, err
}

const deletePrize = `-- name: DeletePrize :exec
DELETE FROM prizes
WHERE prize_name = $1
`

func (q *Queries) DeletePrize(ctx context.Context, prizeName string) error {
	_, err := q.exec(ctx, q.deletePrizeStmt, deletePrize, prizeName)
	return err
}

const getPrizeByPrizeName = `-- name: GetPrizeByPrizeName :one
SELECT prize_id, prize_name, pic_path, weight, reviser_id, revise_time, creator_id, create_time FROM prizes
WHERE prize_name = $1 LIMIT 1
`

func (q *Queries) GetPrizeByPrizeName(ctx context.Context, prizeName string) (Prize, error) {
	row := q.queryRow(ctx, q.getPrizeByPrizeNameStmt, getPrizeByPrizeName, prizeName)
	var i Prize
	err := row.Scan(
		&i.PrizeID,
		&i.PrizeName,
		&i.PicPath,
		&i.Weight,
		&i.ReviserID,
		&i.ReviseTime,
		&i.CreatorID,
		&i.CreateTime,
	)
	return i, err
}

const listRolltable = `-- name: ListRolltable :many
SELECT t1.prize_name, t1.pic_path, t1.weight FROM prizes t1
ORDER BY t1.prize_id
LIMIT $2::int
OFFSET (($1::int - 1) * $2::int)
`

type ListRolltableParams struct {
	Page     int32 `json:"page"`
	Pagesize int32 `json:"pagesize"`
}

type ListRolltableRow struct {
	PrizeName string `json:"prizeName"`
	PicPath   string `json:"picPath"`
	Weight    int32  `json:"weight"`
}

func (q *Queries) ListRolltable(ctx context.Context, arg ListRolltableParams) ([]ListRolltableRow, error) {
	rows, err := q.query(ctx, q.listRolltableStmt, listRolltable, arg.Page, arg.Pagesize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRolltableRow{}
	for rows.Next() {
		var i ListRolltableRow
		if err := rows.Scan(&i.PrizeName, &i.PicPath, &i.Weight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePrize = `-- name: UpdatePrize :one
UPDATE prizes
SET pic_path = $1, weight = $2
WHERE prize_name = $3
RETURNING prize_id, prize_name, pic_path, weight, reviser_id, revise_time, creator_id, create_time
`

type UpdatePrizeParams struct {
	Picpath   string `json:"picpath"`
	Weight    int32  `json:"weight"`
	PrizeName string `json:"prizeName"`
}

func (q *Queries) UpdatePrize(ctx context.Context, arg UpdatePrizeParams) (Prize, error) {
	row := q.queryRow(ctx, q.updatePrizeStmt, updatePrize, arg.Picpath, arg.Weight, arg.PrizeName)
	var i Prize
	err := row.Scan(
		&i.PrizeID,
		&i.PrizeName,
		&i.PicPath,
		&i.Weight,
		&i.ReviserID,
		&i.ReviseTime,
		&i.CreatorID,
		&i.CreateTime,
	)
	return i, err
}
